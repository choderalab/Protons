import numpy as np
import pandas as pd
from pymbar import BAR
from typing import Union, Tuple
import netCDF4


def bar_calibration_data(
    dataframe: pd.DataFrame,
    from_state,
    to_state,
    bootstrap_size=0,
    bootstrap_samples=100,
) -> Tuple[float, float]:
    last_entry = dataframe["update"].idxmax()

    gk_to_name = f"bias_state_{to_state}"
    gk_from_name = f"bias_state_{from_state}"

    # Initial guess from SAMS
    sams_estimate = (
        -dataframe[gk_to_name].iloc[last_entry]
        + dataframe[f"bias_state_{from_state}"].iloc[last_entry]
    )
    fwd_entries = (dataframe.init_macrostate == from_state) & (
        dataframe.prop_macrostate == to_state
    )
    rev_entries = (dataframe.init_macrostate == to_state) & (
        dataframe.prop_macrostate == from_state
    )
    fwd = (
        dataframe[fwd_entries]["work"]
        - dataframe[fwd_entries][gk_to_name]
        + dataframe[fwd_entries][gk_from_name]
    )
    rev = (
        dataframe[rev_entries]["work"]
        - dataframe[rev_entries][gk_from_name]
        + dataframe[rev_entries][gk_to_name]
    )

    fwd = np.asarray(fwd)
    rev = np.asarray(rev)

    if bootstrap_size == 0:
        dF_err: Tuple[float, float] = tuple(BAR(fwd, rev, compute_uncertainty=True))

        return dF_err

    elif bootstrap_size > fwd.size:
        raise ValueError("Bootstrap size larger than number of forward samples.")
    elif bootstrap_size > rev.size:
        raise ValueError("Bootstrap size larger than number of reverse samples.")
    elif bootstrap_size < 0:
        fwd_samples = [
            np.random.choice(fwd, fwd.size, replace=True)
            for _ in range(bootstrap_samples)
        ]
        rev_samples = [
            np.random.choice(rev, rev.size, replace=True)
            for _ in range(bootstrap_samples)
        ]
    else:
        fwd_samples = [
            np.random.choice(fwd, bootstrap_size, replace=True)
            for _ in range(bootstrap_samples)
        ]
        rev_samples = [
            np.random.choice(rev, bootstrap_size, replace=True)
            for _ in range(bootstrap_samples)
        ]

    return (
        BAR(fwd, rev, compute_uncertainty=False),
        float(
            np.std(
                [
                    BAR(fwd_sample, rev_sample, compute_uncertainty=False)
                    for (fwd_sample, rev_sample) in zip(fwd_samples, rev_samples)
                ]
            )
        ),
    )


def _calculate_ncmc_properties(df: pd.DataFrame, timestep_ps: float = 0.002):
    """Private function. Perform a number of operations on a comparison dataframe to add extra columns.

    Parameters
    ----------
    df - A dataframe with data from NCMC proposals, generated by ``dataset_to_dataframe``.

    """
    df = df.loc[df["Initial_State"] != df["Proposed_State"]]
    df["Pair"] = df["Initial_State"] + "->" + df["Proposed_State"]
    df["P_accept"] = np.exp(-1 * df["Work"])
    df[df["P_accept"] > 1.0] = 1.0
    df["ln_P_accept"] = np.log(df.P_accept)
    df["log10_P_accept"] = np.log10(df.P_accept)
    df["picoseconds"] = df["Length"] * timestep_ps
    df["Efficiency"] = df["P_accept"] / df["picoseconds"]

    return df


def calculate_ncmc_acceptance_rate(dataset: netCDF4.Dataset):
    """Calculate the NCMC acceptance rate from a dataset containing Protons/NCMC data
    Parameters
    ----------
    dataset - netCDF4.Dataset, should contain Protons/NCMC data

    Returns
    -------
    float - acceptance rate

    """
    titration_states = dataset["Protons/Titration/state"][:, :]
    initial_states = dataset["Protons/NCMC/initial_state"][:, :]
    proposed_states = dataset["Protons/NCMC/proposed_state"][:, :]
    naccepted = 0
    ntotal = titration_states.shape[0]
    for i in range(ntotal):
        if titration_states[i] == proposed_states[i]:
            if proposed_states[i] != initial_states[i]:
                naccepted += 1

    return float(naccepted) / float(ntotal)
